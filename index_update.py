# -*- coding: utf-8 -*-
"""Index_update.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AvPdDtM_ncXAOwv8-LpQ8C1wbfVJ0tQ8
"""

#!pip install yfinance
import yfinance as yf
data = yf.download('000001.SS', start="2010-01-01", end="2021-03-09")

"""
new_row = {'Open': 0, 'High': 0, 'Low': 0, 'Close': 0, 'Adj Close': 0, 'Volume': 0}
new_row = pd.Series(new_row, name='2021-03-09 00:00:00')
data = data.append(new_row)
"""
new_row = {'Open': 0, 'High': 0, 'Low': 0, 'Close': 3359.29, 'Adj Close': 0, 'Volume': 0}
new_row = pd.Series(new_row, name='2021-03-09 00:00:00')
data = data.append(new_row)

data['Close'] = data['Close'].round(decimals=2)

import pandas as pd
#data = pd.read_csv("000001.SS.csv")

def basicInfo(data):
  print( data.shape, data.head(), data.tail() )
  return 
#basicInfo(data)
data.tail()

def getCopy(data, col1='Date', col2='Close'):
  ti = data[[col2]].copy()
  return ti

import numpy as np

def addMA(ti, name='MA', win=12):
  ti['MA'] = np.nan
  ti['MA'] = ti['Close'].transform(lambda x: x.rolling(window = win).mean())
  return 

def addEMA(ti, name='EMA', span=12):
  ti['EMA'] = ti['Close'].transform(lambda x: x.ewm(span, adjust=False).mean())
  return 

def drawGraph(ti, x_axis='Date', y1='MA', y2='EMA', start=0, end=100):
  ti[start:end].plot(y = ['Close', y1, y2])
  return

ti = getCopy(data)

# 
name = 'MA'
win = 26
addMA(ti, name, win)

name = 'EMA'
span = 26
addEMA(ti, name, span)


print(ti.shape)

start = 2500
end = 2711
drawGraph(ti, start=start, end=end)

ti.tail(30)

import sklearn
from sklearn.preprocessing import MinMaxScaler, StandardScaler
def generate_series(sub_index, n_steps, col):
  scaler = StandardScaler()
  X_data = []
  Y_data = []
  i = 0
  step = 1
  while i < len(sub_index) - n_steps:
    tmp = sub_index[i : i+n_steps + 1][col].to_numpy()
    tmp = tmp.reshape(-1, 1)
    tmp = scaler.fit_transform(tmp)
    x_tmp = tmp[:n_steps]
    y_tmp = tmp[n_steps:n_steps+1]
    X_data.append(x_tmp)
    Y_data.append(y_tmp)
    i = i + step
  return np.array(X_data), np.array(Y_data), scaler

def getWin(close_index, n_steps, ind, col='EMA'):
  scaler = StandardScaler()
  i1 = ind + 1
  i2 = i1 - n_steps
  win = close_index[ col ][i2:i1].to_numpy()
  win = win.reshape(-1, 1)
  #print(close_index[i2:i1])
  tmp = scaler.fit_transform(win)
  real = close_index[ 'Close' ][i2]
  pmn = close_index[ col ][ind]
  return tmp, scaler, real, pmn

def predIndex(close_index, n_steps, ind, model):
  win, slr_tmp, rl, pmn = getWin(close_index, n_steps, ind) #max: 3687
  #print( slr_tmp.inverse_transform(win)[-3:] )
  #print(win[:10])
  y_pred = model.predict( win.reshape(1, n_steps, 1) )
  y_pred = slr_tmp.inverse_transform(y_pred)
  mn = y_pred[0][0]
  print(mn, '----------- first close: ', rl, '\t: last mean: ', pmn)
  return mn

def predIndexNext(close_index, n_steps, ind, y_next, model):
  win, slr_tmp, rl, pmn = getWin(close_index, n_steps, ind) #max: 3687
  #print( slr_tmp.inverse_transform(win)[-3:] )
  #print(win[:10])
  win, slr_tmp = moveForward(win, y_next, slr_tmp)
  y_pred = model.predict( win.reshape(1, n_steps, 1) )
  y_pred = slr_tmp.inverse_transform(y_pred)
  mn = y_pred[0][0]
  print(mn, '\t: last mean: ', y_next)
  return mn

def moveForward(win, y, slr):
  tmp01 = slr.inverse_transform(win)
  tmp02 = np.roll(tmp01, -1)
  tmp02[-1] = y
  scaler = StandardScaler()
  tmp02 = scaler.fit_transform(tmp02)
  return tmp02, scaler

"""
ind = 2710
win, slr_tmp, rl, pmn = getWin(ti, n_steps, ind) #max: 3687
tmp02, slr_tmp = moveForward(win, 3511.678, slr_tmp)
print(tmp02)
print(slr_tmp.inverse_transform(tmp02))
"""

sub_index = ti[ : ]
#sub_index = ti

n_steps = 20
col = 'EMA'
X_data, Y_data, slr = generate_series(sub_index, n_steps, col)
Y_data = Y_data.reshape(-1, 1)
X_data.shape, Y_data.shape

from sklearn.utils import shuffle
X_data, Y_data = shuffle(X_data, Y_data, random_state=0)

slr.inverse_transform(X_data[-1]), slr.inverse_transform(Y_data[-1])

size = len(X_data)

s1 = int( 0.8 * size )
s2 = int( 0.9 * size )

X_train = X_data[:s1, :]
X_valid = X_data[s1:s2, :]
X_test = X_data[s2:, :]

y_train = Y_data[:s1]
y_valid = Y_data[s1:s2]
y_test = Y_data[s2:]

print("size=", size)
print(s1, s2)
print( X_train.shape, y_train.shape )
print( X_valid.shape, y_valid.shape )
print( X_test.shape, y_test.shape )

import tensorflow as tf
from tensorflow import keras

y_pred = X_test[:, -1]
m =np.mean(keras.losses.mean_squared_error(y_test, y_pred))
print(m)

ind = 2711

# model 1
np.random.seed(42)
tf.random.set_seed(42)

model = keras.models.Sequential([
    keras.layers.Flatten(input_shape=[n_steps, 1]),
    keras.layers.Dense(1)
])


model.compile(loss="mse", optimizer="adam")
history = model.fit(X_train, y_train, epochs=30, validation_data=(X_valid, y_valid))

model.evaluate(X_valid, y_valid)

n_steps = 20
mn = predIndex(ti, n_steps, ind, model)
predIndexNext(ti, n_steps, ind, mn, model)

np.random.seed(42)
tf.random.set_seed(42)

model = keras.models.Sequential([
    keras.layers.SimpleRNN(1, input_shape=[None, 1])
])

optimizer = keras.optimizers.Adam(lr=0.005)
model.compile(loss="mse", optimizer=optimizer)
history = model.fit(X_train, y_train, epochs=30, validation_data=(X_valid, y_valid))

model.evaluate(X_valid, y_valid)

n_steps = 20
mn = predIndex(ti, n_steps, ind, model)
predIndexNext(ti, n_steps, ind, mn, model)

np.random.seed(42)
tf.random.set_seed(42)

model = keras.models.Sequential([
    keras.layers.SimpleRNN(20, return_sequences=True, input_shape=[None, 1]),
    keras.layers.SimpleRNN(20, return_sequences=True),
    keras.layers.SimpleRNN(1)
])

model.compile(loss="mse", optimizer="adam")
history = model.fit(X_train, y_train, epochs=30, validation_data=(X_valid, y_valid))

model.evaluate(X_valid, y_valid)

n_steps = 20
mn = predIndex(ti, n_steps, ind, model)
predIndexNext(ti, n_steps, ind, mn, model)

np.random.seed(42)
tf.random.set_seed(42)

model = keras.models.Sequential([
    keras.layers.SimpleRNN(20, return_sequences=True, input_shape=[None, 1]),
    keras.layers.SimpleRNN(20, return_sequences=True),
    keras.layers.SimpleRNN(20),
    keras.layers.Dense(1)
])

model.compile(loss="mse", optimizer="adam")
history = model.fit(X_train, y_train, epochs=30, validation_data=(X_valid, y_valid))

model.evaluate(X_valid, y_valid)

n_steps = 20
mn = predIndex(ti, n_steps, ind, model)
predIndexNext(ti, n_steps, ind, mn, model)

